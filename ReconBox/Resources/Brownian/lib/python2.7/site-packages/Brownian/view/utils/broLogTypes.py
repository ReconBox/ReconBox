"""This file describes the Bro logs and the various field types.

TODO: This needs to be auto-generated and sent to ES by Bro, but currently the field descriptions are just comments."""

class Field(object):
    def __init__(self, name, type, description):
        self.name = name
        self.type = type
        self.description = description

broLogs = {
    "capture_loss": [
        Field("ts", "time", "Timestamp for when the measurement occurred."),
        Field("ts_delta", "interval", "The time delay between this measurement and the last."),
        Field("peer", "string", "In the event that there are multiple Bro instances logging to the same host, this distinguishes each peer with its individual name."),
        Field("gaps", "count", "Number of missed ACKs from the previous measurement interval."),
        Field("acks", "count", "Total number of ACKs seen in the previous measurement interval."),
        Field("percent_lost", "string", "Percentage of ACKs seen where the data being ACKed wasn't seen."),
    ],
    "cluster": [
        Field("ts", "time", "The time at which a cluster message was generated."),
        Field("message", "string", "A message indicating information about the cluster's operation."),
    ],
    "communication": [
        Field("ts", "time", "The network time at which a communication event occurred."),
        Field("peer", "string", "The peer name (if any) for which a communication event is concerned."),
        Field("src_name", "string", "Where the communication event message originated from, that is, either from the scripting layer or inside the Bro process."),
        Field("connected_peer_desc", "string", "TODO: currently unused."),
        Field("connected_peer_addr", "addr", "TODO: currently unused."),
        Field("connected_peer_port", "port", "TODO: currently unused."),
        Field("level", "string", "The severity of the communication event message."),
        Field("message", "string", "A message describing the communication event between Bro or Broccoli instances."),
    ],
    "conn": [
        Field("ts", "time", "This is the time of the first packet."),
        Field("uid", "string", "A unique identifier of the connection."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("proto", "transport_proto", "The transport layer protocol of the connection."),
        Field("service", "string", "An identification of an application protocol being sent over the the connection."),
        Field("duration", "interval", "How long the connection lasted. For 3-way or 4-way connection tear-downs, this will not include the final ACK."),
        Field("orig_bytes", "count", "The number of payload bytes the originator sent. For TCP this is taken from sequence numbers and might be inaccurate (e.g., due to large connections)"),
        Field("resp_bytes", "count", "The number of payload bytes the responder sent. See orig_bytes."),
        Field("conn_state", "string", "<table><thead><th>conn_state</th><th>Meaning</th></thead><tbody><tr><td>S0</td><td>Connection attempt seen, no reply.</tr><tr><td>S1</td><td>Connection established, not terminated.</td></tr><tr><td>SF</td><td>Normal establishment and termination. Note that this is the same symbol as for state S1. You can tell the two apart because for S1 there will not be any byte counts in the summary, while for SF there will be.</td></tr><tr><td>REJ</td><td>Connection attempt rejected.</td></tr><tr><td>S2</td><td>Connection established and close attempt by originator seen (but no reply from responder).</td></tr><tr><td>S3</td><td>Connection established and close attempt by responder seen (but no reply from originator).</td></tr><tr><td>RSTO</td><td>Connection established, originator aborted (sent a RST).</td></tr><tr><td>RSTR</td><td>Established, responder aborted.</td></tr><tr><td>RSTOS0</td><td>Originator sent a SYN followed by a RST, we never saw a SYN-ACK from the responder.</td></tr><tr><td>RSTRH</td><td>Responder sent a SYN ACK followed by a RST, we never saw a SYN from the (purported) originator.</td></tr><tr><td>SH</td><td>Originator sent a SYN followed by a FIN, we never saw a SYN ACK from the responder (hence the connection was \"half\" open).</td></tr><tr><td>SHR</td><td>Responder sent a SYN ACK followed by a FIN, we never saw a SYN from the originator.</td></tr><tr><td>OTH</td><td>No SYN seen, just midstream traffic (a \"partial connection\" that was not later closed).</td></tr></tbody></table"),
        Field("local_orig", "bool", "If the connection is originated locally, this value will be T. If it was originated remotely it will be F. In the case that the Site::local_nets variable is undefined, this field will be left empty at all times."),
        Field("missed_bytes", "count", "Indicates the number of bytes missed in content gaps which is representative of packet loss. A value other than zero will normally cause protocol analysis to fail but some analysis may have been completed prior to the packet loss."),
        Field("history", "string", "Records the state history of connections as a string of letters. For TCP connections the meaning of those letters is:<table><thead><th>Letter</th><th>Meaning</th></thead><tbody><tr><td>s</td><td>a SYN w/o the ACK bit set</td></tr><tr><td>h</td><td>a SYN+ACK (\"handshake\")</td></tr><tr><td>a</td><td>a pure ACK</td></tr><tr><td>d</td><td>packet with payload (\"data\")</td></tr><tr><td>f</td><td>packet with FIN bit set</td></tr><tr><td>r</td><td>packet with RST bit set</td></tr><tr><td>c</td><td>packet with a bad checksum</td></tr><tr><td>i</td><td>inconsistent packet (e.g. SYN+RST bits both set)</td></tr></tbody></table>If the letter is in upper case it means the event comes from the originator and lower case then means the responder. Also, there is compression. We only record one \"d\" in each direction, for instance. I.e., we just record that data went in that direction. This history is not meant to encode how much data that happened to be."),
        Field("tunnel_parents", "set", "If this connection was over a tunnel, indicate the <em>uid</em> values for any encapsulating parent connections used over the lifetime of this inner connection."),
        Field("orig_pkts", "count", "Number of packets the originator sent. Only set if use_conn_size_analyzer = T"),
        Field("orig_ip_bytes", "count", "Number IP level bytes the originator sent (as seen on the wire, taken from IP total_length header field). Only set if use_conn_size_analyzer = T"),
        Field("resp_pkts", "count", "Number of packets the responder sent. See orig_pkts."),
        Field("resp_ip_bytes", "count", "Number IP level bytes the responder sent. See orig_pkts."),
        Field("orig_cc", "string", "The originating endpoint's GeoIP country code."),
        Field("resp_cc", "string", "The responding endpoint's GeoIP country code."),
    ],
    "dns": [
        Field("ts", "time", "The earliest time at which a DNS protocol message over the associated connection is observed."),
        Field("uid", "string", "A unique identifier of the connection over which DNS messages are being transferred."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("proto", "transport_proto", "The transport layer protocol of the connection."),
        Field("trans_id", "count", "A 16 bit identifier assigned by the program that generated the DNS query. Also used in responses to match up replies to outstanding queries."),
        Field("query", "string", "The domain name that is the subject of the DNS query."),
        Field("qclass", "count", "The QCLASS value specifying the class of the query."),
        Field("qclass_name", "string", "A descriptive name for the class of the query."),
        Field("qtype", "count", "A QTYPE value specifying the type of the query."),
        Field("qtype_name", "string", "A descriptive name for the type of the query."),
        Field("rcode", "count", "The response code value in DNS response messages."),
        Field("rcode_name", "string", "A descriptive name for the response code value."),
        Field("QR", "bool", "Whether the message is a query (F) or response (T)."),
        Field("AA", "bool", "The Authoritative Answer bit for response messages specifies that the responding name server is an authority for the domain name in the question section."),
        Field("TC", "bool", "The Truncation bit specifies that the message was truncated."),
        Field("RD", "bool", "The Recursion Desired bit indicates to a name server to recursively purse the query."),
        Field("RA", "bool", "The Recursion Available bit in a response message indicates if the name server supports recursive queries."),
        Field("Z", "count", "A reserved field that is currently supposed to be zero in all queries and responses."),
        Field("answers", "vector", "The set of resource descriptions in answer of the query."),
        Field("TTLs", "vector", "The caching intervals of the associated RRs described by the answers field."),
        Field("ready", "bool", "This value indicates if this request/response pair is ready to be logged."),
        Field("total_answers", "count", "The total number of resource records in a reply message's answer section."),
        Field("total_replies", "count", "The total number of resource records in a reply message's answer, authority, and additional sections."),
    ],
    "dpd": [
        Field("ts", "time", "Timestamp for when protocol analysis failed."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("proto", "transport_proto", "Transport protocol for the violation."),
        Field("analyzer", "string", "The analyzer that generated the violation."),
        Field("failure_reason", "string", "The textual reason for the analysis failure."),
        Field("disabled_aids", "set", "Disabled analyzer IDs. This is only for internal tracking so as to not attempt to disable analyzers multiple times."),
    ],
    "external_dns": [
        Field("ts", "time", "The earliest time at which a DNS protocol message over the associated connection is observed."),
        Field("uid", "string", "A unique identifier of the connection over which DNS messages are being transferred."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("proto", "transport_proto", "The transport layer protocol of the connection."),
        Field("trans_id", "count", "A 16 bit identifier assigned by the program that generated the DNS query. Also used in responses to match up replies to outstanding queries."),
        Field("query", "string", "The domain name that is the subject of the DNS query."),
        Field("qclass", "count", "The QCLASS value specifying the class of the query."),
        Field("qclass_name", "string", "A descriptive name for the class of the query."),
        Field("qtype", "count", "A QTYPE value specifying the type of the query."),
        Field("qtype_name", "string", "A descriptive name for the type of the query."),
        Field("rcode", "count", "The response code value in DNS response messages."),
        Field("rcode_name", "string", "A descriptive name for the response code value."),
        Field("QR", "bool", "Whether the message is a query (F) or response (T)."),
        Field("AA", "bool", "The Authoritative Answer bit for response messages specifies that the responding name server is an authority for the domain name in the question section."),
        Field("TC", "bool", "The Truncation bit specifies that the message was truncated."),
        Field("RD", "bool", "The Recursion Desired bit indicates to a name server to recursively purse the query."),
        Field("RA", "bool", "The Recursion Available bit in a response message indicates if the name server supports recursive queries."),
        Field("Z", "count", "A reserved field that is currently supposed to be zero in all queries and responses."),
        Field("answers", "vector", "The set of resource descriptions in answer of the query."),
        Field("TTLs", "vector", "The caching intervals of the associated RRs described by the answers field."),
        Field("ready", "bool", "This value indicates if this request/response pair is ready to be logged."),
        Field("total_answers", "count", "The total number of resource records in a reply message's answer section."),
        Field("total_replies", "count", "The total number of resource records in a reply message's answer, authority, and additional sections."),
    ],
    "ftp": [
        Field("ts", "time", "Timestamp for when the command was sent."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("user", "string", "User name for the current FTP session."),
        Field("password", "string", "Password for the current FTP session if captured."),
        Field("command", "string", "Command given by the client."),
        Field("arg", "string", "Argument for the command if one is given."),
        Field("mime_type", "string", "Libmagic \"sniffed\" file type if the command indicates a file transfer."),
        Field("mime_desc", "string", "Libmagic \"sniffed\" file description if the command indicates a file transfer."),
        Field("file_size", "count", "Size of the file if the command indicates a file transfer."),
        Field("reply_code", "count", "Reply code from the server in response to the command."),
        Field("reply_msg", "string", "Reply message from the server in response to the command."),
        Field("tags", "set", "Arbitrary tags that may indicate a particular attribute of this command."),
        Field("cwd", "string", "Current working directory that this session is in. By making the default value '/.', we can indicate that unless something more concrete is discovered that the existing but unknown directory is ok to use."),
        Field("cmdarg", "FTP", "Command that is currently waiting for a response."),
        Field("pending_commands", "FTP", "Queue for commands that have been sent but not yet responded to are tracked here."),
        Field("passive", "bool", "Indicates if the session is in active or passive mode."),
        Field("capture_password", "bool", "Determines if the password will be captured for this request."),
    ],
    "http": [
        Field("ts", "time", "Timestamp for when the request happened."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("trans_depth", "count", "Represents the pipelined depth into the connection of this request/response transaction."),
        Field("method", "string", "Verb used in the HTTP request (GET, POST, HEAD, etc.)."),
        Field("host", "string", "Value of the HOST header."),
        Field("uri", "string", "URI used in the request."),
        Field("referrer", "string", "Value of the \"referer\" header. The comment is deliberately misspelled like the standard declares, but the name used here is \"referrer\" spelled correctly."),
        Field("user_agent", "string", "Value of the User-Agent header from the client."),
        Field("request_body_len", "count", "Actual uncompressed content size of the data transferred from the client."),
        Field("response_body_len", "count", "Actual uncompressed content size of the data transferred from the server."),
        Field("status_code", "count", "Status code returned by the server."),
        Field("status_msg", "string", "Status message returned by the server."),
        Field("info_code", "count", "Last seen 1xx informational reply code returned by the server."),
        Field("info_msg", "string", "Last seen 1xx informational reply message returned by the server."),
        Field("filename", "string", "Filename given in the Content-Disposition header sent by the server."),
        Field("tags", "set", "A set of indicators of various attributes discovered and related to a particular request/response pair."),
        Field("username", "string", "Username if basic-auth is performed for the request."),
        Field("password", "string", "Password if basic-auth is performed for the request."),
        Field("capture_password", "bool", "Determines if the password will be captured for this request."),
        Field("proxied", "set", "All of the headers that may indicate if the request was proxied."),
    ],
    "http_external": [
        Field("ts", "time", "Timestamp for when the request happened."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("trans_depth", "count", "Represents the pipelined depth into the connection of this request/response transaction."),
        Field("method", "string", "Verb used in the HTTP request (GET, POST, HEAD, etc.)."),
        Field("host", "string", "Value of the HOST header."),
        Field("uri", "string", "URI used in the request."),
        Field("referrer", "string", "Value of the \"referer\" header. The comment is deliberately misspelled like the standard declares, but the name used here is \"referrer\" spelled correctly."),
        Field("user_agent", "string", "Value of the User-Agent header from the client."),
        Field("request_body_len", "count", "Actual uncompressed content size of the data transferred from the client."),
        Field("response_body_len", "count", "Actual uncompressed content size of the data transferred from the server."),
        Field("status_code", "count", "Status code returned by the server."),
        Field("status_msg", "string", "Status message returned by the server."),
        Field("info_code", "count", "Last seen 1xx informational reply code returned by the server."),
        Field("info_msg", "string", "Last seen 1xx informational reply message returned by the server."),
        Field("filename", "string", "Filename given in the Content-Disposition header sent by the server."),
        Field("tags", "set", "A set of indicators of various attributes discovered and related to a particular request/response pair."),
        Field("username", "string", "Username if basic-auth is performed for the request."),
        Field("password", "string", "Password if basic-auth is performed for the request."),
        Field("capture_password", "bool", "Determines if the password will be captured for this request."),
        Field("proxied", "set", "All of the headers that may indicate if the request was proxied."),
        ],
    "http_sqli": [
        Field("ts", "time", "Timestamp for when the request happened."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("trans_depth", "count", "Represents the pipelined depth into the connection of this request/response transaction."),
        Field("method", "string", "Verb used in the HTTP request (GET, POST, HEAD, etc.)."),
        Field("host", "string", "Value of the HOST header."),
        Field("uri", "string", "URI used in the request."),
        Field("referrer", "string", "Value of the \"referer\" header. The comment is deliberately misspelled like the standard declares, but the name used here is \"referrer\" spelled correctly."),
        Field("user_agent", "string", "Value of the User-Agent header from the client."),
        Field("request_body_len", "count", "Actual uncompressed content size of the data transferred from the client."),
        Field("response_body_len", "count", "Actual uncompressed content size of the data transferred from the server."),
        Field("status_code", "count", "Status code returned by the server."),
        Field("status_msg", "string", "Status message returned by the server."),
        Field("info_code", "count", "Last seen 1xx informational reply code returned by the server."),
        Field("info_msg", "string", "Last seen 1xx informational reply message returned by the server."),
        Field("filename", "string", "Filename given in the Content-Disposition header sent by the server."),
        Field("tags", "set", "A set of indicators of various attributes discovered and related to a particular request/response pair."),
        Field("username", "string", "Username if basic-auth is performed for the request."),
        Field("password", "string", "Password if basic-auth is performed for the request."),
        Field("capture_password", "bool", "Determines if the password will be captured for this request."),
        Field("proxied", "set", "All of the headers that may indicate if the request was proxied."),
        ],
    "intel": [
        Field("ts", "time", "The time at which the intelligence item was seen."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("seen.host", "addr", "The IP address if the data seen is an IP address."),
        Field("seen.str", "string", "The string if the data is about a string."),
        Field("seen.str_type", "string", "The type of data that is in the string if the $str field is set."),
        Field("seen.where", "set", "Where the data was discovered."),
        Field("seen.conn", "connection", " If the data was discovered within a connection, the connection record that can give context to the data."),
        Field("sources", "set", "Sources which supplied data that resulted in this match."),
        ],
    "irc": [
        Field("ts", "time", "Timestamp for when the command was seen."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("nick", "string", "Nick name given for the connection."),
        Field("user", "string", "User name given for the connection."),
        Field("command", "string", "Command given by the client."),
        Field("value", "string", "Value for the command given by the client."),
        Field("addl", "string", "Any additional data for the command."),
    ],
    "known_certs": [
        Field("ts", "time", "The timestamp when the certificate was detected."),
        Field("host", "addr", "The address that offered the certificate."),
        Field("port_num", "port", "If the certificate was handed out by a server, this is the port that the server waslistening on."),
        Field("subject", "string", "Certificate subject."),
        Field("issuer_subject", "string", "Certificate issuer subject."),
        Field("serial", "string", "Serial number for the certificate."),
    ],
    "known_hosts": [
        Field("ts", "time", "The timestamp at which the host was detected."),
        Field("host", "addr", "The address that was detected originating or responding to a TCP connection."),
    ],
    "known_services": [
        Field("ts", "time", "The time at which the service was detected."),
        Field("host", "addr", "The host address on which the service is running."),
        Field("port_num", "port", "The port number on which the service is running."),
        Field("port_proto", "transport_proto", "The transport-layer protocol which the service uses."),
        Field("service", "set", "A set of protocols that match the service's connection payloads."),
    ],
    "loaded_scripts": [
        Field("name", "string", "Name of the script loaded potentially with spaces included before the file name to indicate load depth. The convention is two spaces per level of depth."),
    ],
    "metrics": [
        Field("ts", "time", "Timestamp at which the metric was broken."),
        Field("metric_id", "Metrics", "What measurement the metric represents."),
        Field("filter_name", "string", "The name of the filter being logged. Metrics::ID values can have multiple filters which represent different perspectives on the data so this is necessary to understand the value."),
        Field("index", "Metrics", "What the metric value applies to."),
        Field("value", "count", "The simple numeric value of the metric."),
    ],
    "notice": [
        Field("ts", "time", "An absolute time indicating when the notice occurred, defaults to the current network time."),
        Field("uid", "string", "A connection UID which uniquely identifies the endpoints concerned with the notice."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("conn", "connection", "A shorthand way of giving the uid and id to a notice. The reference to the actual connection will be deleted after applying the notice policy."),
        Field("iconn", "icmp_conn", "A shorthand way of giving the uid and id to a notice. The reference to the actual connection will be deleted after applying the notice policy."),
        Field("proto", "transport_proto", "The transport protocol. Filled automatically when either conn, iconn or p is specified."),
        Field("note", "Notice", "The Notice::Type of the notice."),
        Field("msg", "string", "The human readable message for the notice."),
        Field("sub", "string", "The human readable sub-message."),
        Field("src", "addr", "Source address, if we don't have a conn_id."),
        Field("dst", "addr", "Destination address."),
        Field("p", "port", "Associated port, if we don't have a conn_id."),
        Field("n", "count", "Associated count, or perhaps a status code."),
        Field("src_peer", "event_peer", "Peer that raised this notice."),
        Field("peer_descr", "string", "Textual description for the peer that raised this notice."),
        Field("actions", "set", "The actions which have been applied to this notice."),
        Field("policy_items", "set", "These are policy items that returned T and applied their action to the notice."),
        Field("email_body_sections", "vector", "By adding chunks of text into this element, other scripts can expand on notices that are being emailed. The normal way to add text is to extend the vector by handling the Notice::notice event and modifying the notice in place."),
        Field("email_delay_tokens", "set", "Adding a string \"token\" to this set will cause the notice framework's built-in emailing functionality to delay sending the email until either the token has been removed or the email has been delayed for Notice::max_email_delay."),
        Field("identifier", "string", "This field is to be provided when a notice is generated for the purpose of deduplicating notices. The identifier string should be unique for a single instance of the notice. This field should be filled out in almost all cases when generating notices to define when a notice is conceptually a duplicate of a previous notice. For example, an SSL certificate that is going to expire soon should always have the same identifier no matter the client IP address that connected and resulted in the certificate being exposed. In this case, the resp_h, resp_p, and hash of the certificate would be used to create this value. The hash of the cert is included because servers can return multiple certificates on the same port. Another example might be a host downloading a file which triggered a notice because the MD5 sum of the file it downloaded was known by some set of intelligence. In that case, the orig_h (client) and MD5 sum would be used in this field to dedup because if the same file is downloaded over and over again you really only want to know about it a single time. This makes it possible to send those notices to email without worrying so much about sending thousands of emails."),
        Field("suppress_for", "interval", "This field indicates the length of time that this unique notice should be suppressed. This field is automatically filled out and should not be written to by any other script."),
    ],
    "notice_alarm": [
        Field("ts", "time", "An absolute time indicating when the notice occurred, defaults to the current network time."),
        Field("uid", "string", "A connection UID which uniquely identifies the endpoints concerned with the notice."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("conn", "connection", "A shorthand way of giving the uid and id to a notice. The reference to the actual connection will be deleted after applying the notice policy."),
        Field("iconn", "icmp_conn", "A shorthand way of giving the uid and id to a notice. The reference to the actual connection will be deleted after applying the notice policy."),
        Field("proto", "transport_proto", "The transport protocol. Filled automatically when either conn, iconn or p is specified."),
        Field("note", "Notice", "The Notice::Type of the notice."),
        Field("msg", "string", "The human readable message for the notice."),
        Field("sub", "string", "The human readable sub-message."),
        Field("src", "addr", "Source address, if we don't have a conn_id."),
        Field("dst", "addr", "Destination address."),
        Field("p", "port", "Associated port, if we don't have a conn_id."),
        Field("n", "count", "Associated count, or perhaps a status code."),
        Field("src_peer", "event_peer", "Peer that raised this notice."),
        Field("peer_descr", "string", "Textual description for the peer that raised this notice."),
        Field("actions", "set", "The actions which have been applied to this notice."),
        Field("policy_items", "set", "These are policy items that returned T and applied their action to the notice."),
        Field("email_body_sections", "vector", "By adding chunks of text into this element, other scripts can expand on notices that are being emailed. The normal way to add text is to extend the vector by handling the Notice::notice event and modifying the notice in place."),
        Field("email_delay_tokens", "set", "Adding a string \"token\" to this set will cause the notice framework's built-in emailing functionality to delay sending the email until either the token has been removed or the email has been delayed for Notice::max_email_delay."),
        Field("identifier", "string", "This field is to be provided when a notice is generated for the purpose of deduplicating notices. The identifier string should be unique for a single instance of the notice. This field should be filled out in almost all cases when generating notices to define when a notice is conceptually a duplicate of a previous notice. For example, an SSL certificate that is going to expire soon should always have the same identifier no matter the client IP address that connected and resulted in the certificate being exposed. In this case, the resp_h, resp_p, and hash of the certificate would be used to create this value. The hash of the cert is included because servers can return multiple certificates on the same port. Another example might be a host downloading a file which triggered a notice because the MD5 sum of the file it downloaded was known by some set of intelligence. In that case, the orig_h (client) and MD5 sum would be used in this field to dedup because if the same file is downloaded over and over again you really only want to know about it a single time. This makes it possible to send those notices to email without worrying so much about sending thousands of emails."),
        Field("suppress_for", "interval", "This field indicates the length of time that this unique notice should be suppressed. This field is automatically filled out and should not be written to by any other script."),
    ],
    "notice_policy": [
        Field("position", "count", "This is the exact positional order in which the Notice::PolicyItem records are checked. This is set internally by the notice framework."),
        Field("priority", "count", "Define the priority for this check. Items are checked in ordered from highest value (10) to lowest value (0)."),
        Field("action", "Notice", "An action given to the notice if the predicate return true."),
        Field("pred", "function", "The pred (predicate) field is a function that returns a boolean T or F value. If the predicate function return true, the action in this record is applied to the notice that is given as an argument to the predicate function. If no predicate is supplied, it's assumed that the PolicyItem always applies."),
        Field("halt", "bool", "Indicates this item should terminate policy processing if the predicate returns T."),
        Field("suppress_for", "interval", "This defines the length of time that this particular notice should be suppressed."),
    ],
    "packet_filter": [
        Field("ts", "time", "The time at which the packet filter installation attempt was made."),
        Field("node", "string", "This is a string representation of the node that applied this packet filter. It's mostly useful in the context of dynamically changing filters on clusters."),
        Field("filter", "string", "The packet filter that is being set."),
        Field("init", "bool", "Indicate if this is the filter set during initialization."),
        Field("success", "bool", "Indicate if the filter was applied successfully."),
    ],
    "reporter": [
        Field("ts", "time", "The network time at which the reporter event was generated."),
        Field("level", "Reporter", "The severity of the reporter message."),
        Field("message", "string", "An info/warning/error message that could have either been generated from the internal Bro core or at the scripting-layer."),
        Field("location", "string", "This is the location in a Bro script where the message originated. Not all reporter messages will have locations in them though."),
    ],
    "signatures": [
        Field("ts", "time", "The network time at which a signature matching type of event to be logged has occurred."),
        Field("src_addr", "addr", "The host which triggered the signature match event."),
        Field("src_port", "port", "The host port on which the signature-matching activity occurred."),
        Field("dst_addr", "addr", "The destination host which was sent the payload that triggered the signature match."),
        Field("dst_port", "port", "The destination host port which was sent the payload that triggered the signature match."),
        Field("note", "Notice", "Notice associated with signature event"),
        Field("sig_id", "string", "The name of the signature that matched."),
        Field("event_msg", "string", "A more descriptive message of the signature-matching event."),
        Field("sub_msg", "string", "Extracted payload data or extra message."),
        Field("sig_count", "count", "Number of sigs, usually from summary count."),
        Field("host_count", "count", "Number of hosts, from a summary count."),
    ],
    "smtp": [
        Field("ts", "time", "Timestamp when the message was first seen."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("trans_depth", "count", "A count to represent the depth of this message transaction in a single connection where multiple messages were transferred."),
        Field("helo", "string", "Contents of the Helo header."),
        Field("mailfrom", "string", "Contents of the From header."),
        Field("rcptto", "set", "Contents of the Rcpt header."),
        Field("date", "string", "Contents of the Date header."),
        Field("from", "string", "Contents of the From header."),
        Field("to", "set", "Contents of the To header."),
        Field("reply_to", "string", "Contents of the ReplyTo header."),
        Field("msg_id", "string", "Contents of the MsgID header."),
        Field("in_reply_to", "string", "Contents of the In-Reply-To header."),
        Field("subject", "string", "Contents of the Subject header."),
        Field("x_originating_ip", "addr", "Contents of the X-Originating-IP header."),
        Field("first_received", "string", "Contents of the first Received header."),
        Field("second_received", "string", "Contents of the second Received header."),
        Field("last_reply", "string", "The last message the server sent to the client."),
        Field("path", "vector", "The message transmission path, as extracted from the headers."),
        Field("user_agent", "string", "Value of the User-Agent header from the client."),
        Field("progress_received_from", "bool", "Indicates if the \"Received: from\" headers should still be processed."),
        Field("has_client_activity", "bool", "Indicates if client activity has been seen, but not yet logged."),
    ],
    "smtp_entities": [
        Field("ts", "time", "Timestamp when the MIME content transfer began."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("trans_depth", "count", "A count to represent the depth of this message transaction in a single connection where multiple messages were transferred."),
        Field("filename", "string", "The filename seen in the Content-Disposition header."),
        Field("content_len", "count", "Track how many bytes of the MIME encoded file have been seen."),
        Field("mime_type", "string", "The mime type of the entity discovered through magic bytes identification."),
        Field("md5", "string", "The calculated MD5 sum for the MIME entity."),
        Field("calc_md5", "bool", "Optionally calculate the file's MD5 sum. Must be set prior to the first data chunk being see in an event."),
        Field("calculating_md5", "bool", "This boolean value indicates if an MD5 sum is being calculated for the current file transfer."),
        Field("extract_file", "bool", "Optionally write the file to disk. Must be set prior to first data chunk being seen in an event."),
        Field("extraction_file", "file", "Store the file handle here for the file currently being extracted."),
    ],
    "socks": [
        Field("ts", "time", "Timestamp when the proxy connection was first detected."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("version", "count", "Protocol version of SOCKS."),
        Field("user", "string", "Username for the proxy if extracted from the network."),
        Field("status", "string", "Server status for the attempt at using the proxy."),
        Field("request", "SOCKS::Address", "Client requested SOCKS address.  Could be an address, a name or both."),
        Field("request_p", "port", "Client requested port."),
        Field("bound", "SOCKS::Address", "Server bound address.  Could be an address, a name or both."),
        Field("bound_p", "port", "Server bound port."),
    ],
    "software": [
        Field("ts", "time", "Timestamp when the software was first detected."),
        Field("host", "addr", "The IP address detected running the software."),
        Field("host_p", "port", "The port detected running the software."),
        Field("software_type", "Software", "The type of software detected (e.g. HTTP::SERVER)."),
        Field("name", "string", "Name of the software (e.g. Apache)."),
        Field("version", "Software", "Version of the software."),
        Field("version.major", "Software", "Major version of the software."),
        Field("version.minor", "Software", "Minor version of the software."),
        Field("version.minor2", "Software", "Minor minor version of the software."),
        Field("unparsed_version", "string", "The full unparsed version string found because the version parsing doesn't always work reliably in all cases and this acts as a fallback in the logs."),
        Field("force_log", "bool", "This can indicate that this software being detected should definitely be sent onward to the logging framework. By default, only software that is \"interesting\" due to a change in version or it being currently unknown is sent to the logging framework. This can be set to T to force the record to be sent to the logging framework if some amount of this tracking needs to happen in a specific way to the software."),
        Field("url", "string", "Most root URL where the software was discovered."),
    ],
    "ssh": [
        Field("ts", "time", "Timestamp when the SSH connection was first detected."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("status", "string", "Indicates if the login was heuristically guessed to be \"success\" or \"failure\"."),
        Field("direction", "Direction", "Direction of the connection. If the client was a local host logging into an external host, this would be OUTBOUND. INBOUND would be set for the opposite situation."),
        Field("client", "string", "Software string given by the client."),
        Field("server", "string", "Software string given by the server."),
        Field("resp_size", "count", "Amount of data returned from the server. This is currently the only measure of the success heuristic and it is logged to assist analysts looking at the logs to make their own determination about the success on a case-by-case basis."),
        Field("done", "bool", "Indicate if the SSH session is done being watched."),
    ],
    "ssl": [
        Field("ts", "time", "Timestamp when the SSL connection was first detected."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("version", "string", "SSL/TLS version the server offered."),
        Field("cipher", "string", "SSL/TLS cipher suite the server chose."),
        Field("server_name", "string", "Value of the Server Name Indicator SSL/TLS extension. It indicates the server name that the client was requesting."),
        Field("session_id", "string", "Session ID offered by the client for session resumption."),
        Field("subject", "string", "Subject of the X.509 certificate offered by the server."),
        Field("not_valid_before", "time", "NotValidBefore field value from the server certificate."),
        Field("not_valid_after", "time", "NotValidAfter field value from the serve certificate."),
        Field("last_alert", "string", "Last alert that was seen during the connection."),
        Field("cert", "string", "Full binary server certificate stored in DER format."),
        Field("cert_chain", "vector", "Chain of certificates offered by the server to validate its complete signing chain."),
        Field("analyzer_id", "count", "The analyzer ID used for the analyzer instance attached to each connection. It is not used for logging since it's a meaningless arbitrary number."),
    ],
    "stats": [
        Field("ts", "time", "Timestamp for the measurement."),
        Field("peer", "string", "Peer that generated this log. Mostly for clusters."),
        Field("mem", "count", "Amount of memory currently in use in MB."),
        Field("pkts_proc", "count", "Number of packets processed since the last stats interval."),
        Field("events_proc", "count", "Number of events that been processed since the last stats interval."),
        Field("events_queued", "count", "Number of events that have been queued since the last stats interval."),
        Field("lag", "interval", "Lag between the wall clock and packet timestamps if reading live traffic."),
        Field("pkts_recv", "count", "Number of packets received since the last stats interval if reading live traffic."),
        Field("pkts_dropped", "count", "Number of packets dropped since the last stats interval if reading live traffic."),
        Field("pkts_link", "count", "Number of packets seen on the link since the last stats interval if reading live traffic."),
    ],
    "syslog": [
        Field("ts", "time", "Timestamp when the syslog message was seen."),
        Field("uid", "string", "Connection unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port."),
        Field("proto", "transport_proto", "Protocol over which the message was seen."),
        Field("facility", "string", "Syslog facility for the message."),
        Field("severity", "string", "Syslog severity for the message."),
        Field("message", "string", "The plain text message."),
    ],
    "tunnel": [
        Field("ts", "time", "Timestamp when some tunnel activity occurred."),
        Field("uid", "string", "Unique ID for the tunnel - may correspond to connection uid or be non-existant"),
        Field("id.orig_h", "addr", "The originating endpoint's address."),
        Field("id.orig_p", "port", "The originating endpoint's port - 0 in the case of an IP tunnel."),
        Field("id.resp_h", "addr", "The responding endpoint's address."),
        Field("id.resp_p", "port", "The responding endpoint's port - 0 in the case of an IP tunnel."),
        Field("tunnel_type", "Tunnel::Type", "The type of tunnel."),
        Field("action", "Action", "The type of activity that occured."),
    ],
    "weird": [
        Field("ts", "time", "Timestamp when the weird occurred."),
        Field("uid", "string", "If a connection is associated with this weird, this will be the connection's unique ID."),
        Field("id.orig_h", "addr", "The originating endpoint's address - optional."),
        Field("id.orig_p", "port", "The originating endpoint's port - optional."),
        Field("id.resp_h", "addr", "The responding endpoint's address - optional."),
        Field("id.resp_p", "port", "The responding endpoint's port - optional."),
        Field("name", "string", "The name of the weird that occurred."),
        Field("addl", "string", "Additional information accompanying the weird if any."),
        Field("notice", "bool", "Indicate if this weird was also turned into a notice."),
        Field("peer", "string", "The peer that originated this weird. This is helpful in cluster deployments if a particular cluster node is having trouble to help identify which node is having trouble."),
    ],
}
